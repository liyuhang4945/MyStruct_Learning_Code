# 数据结构

程序=数据结构+算法

```
常用预定义常量和类型
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2


typedef int Status;
typedef char ElemType;
```



## 01-基本概念

### 数据 》数据元素》数据项

- 各种符号的集合
  - 信息的载体
  - 能被计算机识别，存储加工
- 包括
  - 数值
  - 非数据

### 数据元素

- 是一个整体，来考虑和处理
- 是数据的基本单位，
- 与数据的关系
  - 是集合的个体

### 数据项

- 构成数据元素的最小单元

### 数据对象

- 性质相同的数据元素的集合
- 与数据的关系
  - 是集合的子集

### 数据结构

- 数据元素之间的关系
- 相互之间存在的一种或多种特定关系的数据元素集合
- 数据元素是带结构的数据元素的集合

1. 数据元素之间的逻辑关系  **逻辑结构**
   - 逻辑结构
     - 描述数据元素之间的逻辑关系
     - 与存储无关
     - 从具体问题中抽象出来的数学模型
     - 种类
       - 线性
       - 非线性
     - 四类基本
       - 集合
       - 线性
       - 树
       - 图
2. 数据元素及其关系在内存中的表示（映像），**物理结构**或**存储结构**
   - 物理结构
     - 数据元素及其关系在计算机中的结构
     - 存储结构
       - 顺序存储
       - 链式存储
       - 索引存储
         - 建立附加的索引表
       - 
3. 数据的运算和实现
   1. 对数据元素可以施加的操作及其相应存储结构的实现



### 数据类型与抽象数据类型

- 定义

  - 数据类型是一组性质相同的**值得集合**以及
  - =值的集合+值集合上的操作

- 抽象数据类型 ADT

  - ```
    ADT 类型名
    {
    	数据对象
    	数据关系
    	基本操作
    		基本操作名（参数）
    		初始条件	
    		操作结果
    }ADT 类型名
    ```

    

### 算法的定义

- 对特定问题求解方法和步骤的一种描述
- 五个重要特性
  - 有穷性
  - 确定性
    - 无二义性 ，相同的输入得到相同的结果
  - 可行性
    - 可执行，通过已经实现的基本操作执行有限次实现
  - 输入
  - 输出

#### 设计的要求

- 正确性
  - 不含语法错误
  - 得到满足要求的结果
  - 对应特定输入得到满足要求的结果
- 可读性
- 健壮性
  - 非法数据，做出相应的反应，
- 高效性

### 算法分析

- 正确性，健壮性，可读性，然后考虑**算法的效率**

- 算法的效率

  - 时间效率

    - 算法消耗的时间

    - 度量方法

      - 事后分析

      - 事前分析

        - ```
          算法运行时间=所需时间*操作次数
          假设每条语句均为单位时间
          
          算法所耗费的时间=每条语句的频度之和
          T（n）
          
          时间复杂度o（f(n)）
          ```

          

  - 空间效率

    - 执行过程中消耗的空间

  

## 02-线性表

- 顺序存储
- 链式存储

### 02-1定义和特点

- 具有相同特征的数据元素的一个有限序列
- 元素的个数N为表的长度
- N=0时称为空表

### 02-3类型定义

```
InitList(&L);//构造一个空的线性表

DestroyList(&L) //销毁线性表
ClearList(&L)//清空线性表
ListEmpty(&L) //空表返回TRUE 否则返回FLALSE
    ListLength(&L) 返回线性表中元素的个数
    
GetElem(&L,i,&e)//用e返回线性表L中第I个数据元素的值
LocateElem（&L,e,compare()) 返回L中第一个与e满足compare的数据元素，不存在返回0
PriorElem（&L，cur_e,&pre_e)
PriorElem（&L，cur_e,&pre_e)
NextElem（&L，cur_e,&Next_e)
ListInsert(&L,i,e)L的长度+1
ListDelete（&L，i，&e）
ListTraverse(&L,visited()) 依次调用visited（）
    
```

### 02-4顺序表示与实现

```
#include<stdlib.h>
typedef struct{
	ElemType data[SIZE]
	int length;
}SqList;
typedef struct{
	ElemType *data; = (ElemType*)malloc(sizeof((ElemType)*SIZE); free（p） 释放p指针所指变量的空间
	int length;
}SqList;


初始化
Status InitListSq（SqList&L)
{
	L.elem= new ElemAType[SIZE];
	if(!L.elem)
	{
		exit(OVERFLOW);
	}
	L.length = 0;
	return OK;
}
```

顺序表==数组

- 地址连续

- 依次存放

- 随机存取

- 类型相同
  
  - 线性表长度可变
  
  ## 期望值-平均查找长度-ASL
  
  ```
  ASL=（i=1--》i=n)PiCi
  p=第i个记录被查找的概论
  c=找到第n个记录需要比较的次数
  ```
  

### 02-5顺序表的优缺点

- 任一元素均可随机存取
- 缺点
  - 每次移动需要移动大量的元素

### 02-6链式表示

#### 特点

- 每一个结点分为两个域
  - 数据域
  - 指针域

#### 相关术语

- 结点	： 数据元素的存储映像、

- 链表： n个结点由指针链组成的

- 单链表

  - 结点只有一个指针域的链表

- 双链表

  - 结点只有两个指针域的链表

- 循环链表

  - 首尾相接的链表称为循环链表

- 头指针

  - 指向第一个结点的指针

- 头节点

  - 在首元结点之前附设的一个结点
  - 便于首元结点的处理
  - 判空
    - L.next== NULL

- 首元结点

  - 第一个存储数据的结点

  



## 03栈和队列

- #### 操作受限的线性表



## 04-串，数组和广义表

- #### 内容受限的线性表

### 串

- 零个或多个   任意字符组成的有限序列

  - ```
    S = "ABCDEFG";
    串名 	串值
    n = 串长
    ```

#### 字串

- 任意个连续字符组成的子序列

#### 真字串

- 不包含自身的所有子串

#### 字符位置

- 字符在序列中的序号

#### 子串位置

- 字串第一个字符在主串中的位置

#### 空格串

- 由一个或多个空格组成的串，与空串不同

#### 定义，结构，运算

##### 定义 顺序

```
#define MAXLEN 255
SString{
	char ch[MAXLEN+1];
    int length;
}

StrAssign
StrCompare
StrLength
Concat

SubString
StrCopy
ClearString
Index
Replace
StrInsert
StrDelete
DestroyString
```

#### 链式存储结构

- 操作方便

- 但存储密度较低

  - ```
    密度 = 串值所占的内存/实际分配的内存
    可以将多个字符防止同一个结点中
    ```

  - 类型定义

  - ```
    #define CHUNKSIZE 80
    typedef struct Chunk{
    	char ch[CHUNKSIZE];
    	struct Chunk *next;
    }
    
    typedef struct{
    	Chunk *head,*tail;
    	int curlen;
    }Lstring;
    ```

#### 模式匹配算法

- 目的 （定位）

  - 确定主串中 所含子串（模式串）第一次出现的位置

  - 应用

    - 搜索引擎，checkingSpell 翻译，数据压缩

  - 种类

    - BF算法　Ｂｒｕｔｅ　Ｆｏｒｃｅ

      - 时间复杂度

        - 若ｎ为主串长度，Ｍ为子串长度，
        - 最好　ｏ（Ｍ）
        - 最坏　　（Ｎ－Ｍ）＊ｍ＋Ｍ　
          - 若ｍ《《ｎ　则ｏ（Ｍ＊ｎ）
        - 平均　Ｏ（ｎ／２＊ｍ）

      - ```ｃｐｐ
        ｖｏｉｄ　ＢＦ（Ｓｔｒｉｎｇ　＆Ｓ１，Ｓｔｒｉｎｇ　＆ｓ２）｛
        	ｉｎｔ　ｉ　＝　１；
        	ｉｎｔ　ｊ　＝　１；
        	
        	
        	匹配失败
        	ｉ　＝　ｉ－ｊ　＋　２　（回溯到原本位置＋１的位置）
        	ｊ　＝　１；
        ｝
        
        ｖｏｉｄ　Ｉｎｄｅｘ＿ＢＦ（ＳＳｔｒｉｎｇ　ｓ，ＳＳｔｒｉｎｇ　Ｔ）｛
        	ｉｎｔ　ｉ　＝　１；
        	ｉｎｔ　ｊ　＝　１；
        	ｗｈｉｌｅ（ｉ＜＝Ｓ．ｌｅｎｇｔｈ　＆＆　ｊ＜＝　Ｔ．ｌｅｎｇｔｈ）｛
        		ｉｆ（Ｓ．ｃｈ［ｉ］＝＝　ｔ．ｃｈ［ｊ］）｛
        			＋＋ｉ；
        			＋＋ｊ；
        		｝ｅｌｓｅ｛
        		子串回溯　重新　开始　下一次匹配
        		ｉ　＝　ｉ－ｊ　＋　２；
        		ｊ　＝　１；
        		｝
        	｝
        	
        	ｉｆ（ｊ＞＝Ｔ．ｌｅｎｇｔｈ）｛
        		匹配成功，此时　ｊ＝　T．ｌｅｎｇｔｈ＋１；　ｉ等于主串中子串最后一个的位置的下标。
        		ｒｅｔｕｒｎ　ｉ　－　Ｔ．ｌｅｎｇｔｈ；
        	｝ｅｌｓｅ｛
        		ｒｅｔｕｒｎ　０；
        	｝
        ｝
        ```

        

    - ＫＭＰ算法

    - ｉ不回溯，，最高可提速至Ｏ（ｎ＋Ｍ）

      - ```
    next[j]  MAX{k|1<k<j;} 从头开始的k-1个元素，与当前位置的前面的k-1元素，匹配多少个 +1 就是 K 的值
        		0 	j=1
        		1   other
        		
        		
        
        j   	 |  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
        模式串	   |  a b c a a b b c a  b  c  a  a  b  d  a  b
        next[j]  |  0 1 1 1 2 2 3 1 1  2  3  4  5  6  7  1  2
        
        int Index_KMP(S1,T,int pos){
        	i= pos;
        	j = 1;
        	while(i<S.length&&j<T.length){
        		if(j==0||S.ch[i] == T.ch[j]){
        			i++;
        			j++;
        		}else{
        			j=next[j];
        		}
        	}
        	
        	if(J>T.length){
        		return i-T.length;
        	}
        	else{
        		return 0;
        	}
        }
        
        void get_Next(T,int&next[]){
        	i = 1;
        	next[1] = 0;
        	j = 0;
        	while(i<T.length){
        		if(J==0||T.ch[i]==T.ch[j]){
        			++i;
        			++j;
        			next[i] = j;
        		}else{
        			j= next[j];
        		}
        	}
        }
        
        void get_NextVal(T,int&nextval[]){
        	int nextval[1] = 0;
        	int i = 1;
        	j = 0;
        	while(i<T.length){
        		if(j==0|| T.ch[i]==T.ch[j]){
        			++i;
        			++j;
        			if(T.ch[i]!= T.ch[j]){
        				nextval[i] = j;
        				
        			}else{
        				nextval[i] = nextval[j];
        			}
        		}else{
        			j = nextval[j];
        		}
        	}
        }
        ```
    
    
    
    
    
    
    
    
    

### 数组

1. 地址计算

   1. ```
      loc(0) = a = 2000 L = elemSize;
      loc(3) = a+ 3*L; 
      loc(i-1) = a+ (i-1)*L;
      ```

2. 矩阵

   1. 一个M*N个元素组成的m行n列的表

   2. 随机存取，密度为1

      1. 对称

         1. M*M  --》 n(n+1)/2

      2. 三角矩阵

         1. 对角线以上，（不包括对角线）的全部为常数C

            - 重复元素共享一个，共占用n（n+1）/2 +1

            - ```
              
              上三角
              k={（i-1)*(2n-1+2)/2 + j-i +1} i<=j
              k= {(n*（n+1)/2+1}    i> j 
              下三角
              k = {i*（i-1）/2 + j }
              ```

      3. 对角

         1. 对角线旁边才有值，

      4. 稀疏矩阵

         1. delt = t/(M*N)

         2. 当delt 《= 0.05 时为稀疏矩阵 

         3. 三元组 {i，j, ;elem}

         4. 在添加一个总行数，列数，非零个数

         5. 压缩原则

            1. 存非零云的值，行列位置，和矩阵的行列式

         6. 十字链表

            1. 灵活插入运算产生的新非零元素，删除因运算产生的零元素

            2. 每一个非零元素用一个结点表示，

            3. ```
               结点由
               {
               	row;行
               	col;列
               	value;值
               	right;同行中的下一个非零元素
               	down;同列中的下一个
               }
               ```

3. 广义表

   - n个元素的有限序列，每一个元素可以是一个原子（单一元素）或者一个广义表
   - LS = （A1，A2.。。An）
     - ls=表名
     - n为长度
     - a为元素
   - head = （A1)
   - tail = (A2-a3-an);

## 5-树

- define

  - 树是n》0 个节点的有限集 递归的定义

    - n=0 空树

    - n 》0  满足如下两个条件

      1. 有且只有一个特定的 **根**节点
      2. 其余节点可分为m（》0）的互不相交的有限集，其中每一个集合本身又是一课树，并称为根的**子树**
- 表示方法
  - 广义表
  - 嵌套结构
  - 层次结构
  - 树结构


### -1基本术语

- 节点：
  - 数据元素以及指向子树的分支
- 根节点
  - 非空树中无前驱节点的节点
- 节点的度
  - 节点拥有的子数的个数
- 树的度
  - 树内各节点的度的最大值
- 叶子，终端节点
  - 度为零
- 非终端节点，内部节点
  - 度！= 0
- 双亲 孩子
  - 节点的子树的根称为该节点的孩子
  - 该节点称为孩子的双亲
- 祖先
  - 从根到该节点所经分支上的所有节点
- 子孙
  - 以某节点为根的子树中的任一节点
- 树的深度
  - 节点层次的高度
  - 根结点为第一层
    - 同层的结点为堂兄弟
- 有序树
  - 书中节点的个子树从左至右有次序
- 无序树
  - 书中节点无序
- 森林
  - m》0 棵互不相交的树的集合
  - 树一定是森林
  - 森林不一定是树

### -2二叉树的定义

二叉树结构简单 规律性强

所有的树都能转为唯一对应的二叉树

- 定义
  - 一个根节点 两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成
- 特点
  1. 每个节点最多两个孩子 二叉树中不存在度（结点的子树的个数）大于二的
  2. 有左右之分
  3. 二叉树可以是空集合
  4. 二叉树不是树的特性情况
     1. 二叉树严格区分 左右 子树
     2. 树当只有一个孩子时 无需区分
- 三个结点的二叉树具有五种形态
- 而树只有两种形态
- 二叉树的五种基本形态
  - 空
  - 根和空子树
  - 根和左子树
  - 根和右子树
  - 根和左右子树

#### -2-1抽象数据类型定义

```
struct BinaryTree{
	
}
CreateBiTree(&T,definition)
	按definition 构造二叉树
PreOrderTraverse（&T）
	先序遍历
InOrderTraverse（&T）
	中序
PostOrderTraverse（&T）
	后序

```





#### -2-2性质和存储结构

##### 性质：

1. 在二叉树的第i层至多可以有 2的^(i-1) 个节点 i》= 1
2. 深度 为k的二叉树至多有2^k-1个节点
   - ​		至少有  K  个节点
3. 对任何一个二叉树T，如果其叶子数为N， 度为2的节点数为M
   1. 则N = M + 1
   2. 总边数 为总节点 - 1

##### 存储结构：



### 满二叉树

定义：一颗深度为k 且有2^k   -  - 1个节点的二叉树为满二叉树

特定：

1. 每一层的节点都是最大节点
2. 叶子节点都在最底层
3. 节点编号自上而下，自左向右

### 完全二叉树

- 节点编号和满二叉树一一对应，
- 在满二叉树中，从最后一个节点开始，连续去掉任意个节点，既是一颗完全二叉树
- 具有n个节点的完全二叉树的深度为[     log2N      ] + 1
- 对任一节点编号
  - i = 1 则节点i 是二叉树的根，若i》1 双亲是 节点[i/2]
  - 如果2i 》 n(n是节点总数) 则节点i 是叶子节点，无左子，否则，其左子为节点2 i
  - 如果 2i+1 》 n 则节点i 无右子，否则，其右子为结点2i+1 

特点

1. 叶子只可能分布在层次最大的两层上
2. 对任一节点，若右子树的最大层次为 i 左边的最大层次必为i+1或I



### 二叉树的顺序存储结构

- 实现



在n个节点的二叉链表，有n+1个空指针域



必有2n个链域，除根节点，每个节点只有一个双亲，只有n-1个节点的链域存放指针



### 遍历二叉树

- 定义，
  - 顺着搜索路径巡抚二叉树中的节点，每个节点均且仅访问一次
- 方法
  - L 遍历左子树，D访问根节点，R 遍历右子树
  - DLR  LDR，LRD
  - 先序
  - 中序
  - 后序
- 由先序和中序，或后序和中序，可以确定唯一一颗二叉树

建立二叉树

复制二叉树

计算二叉树深度

计算节点数

计算叶子节点数

### 线索二叉树

- 线索：某个节点的左孩子为空，则指向其前驱，右孩子违抗则指向其后继

- 改变指向的指针，称为线索

- 遍历，根据遍历的先后顺序，调整指针

- ```
  Ltag = 0 Lchild指向该节点的左孩子
  Ltag = 1 Lchild指向该节点的前驱
  Rtag = 0 Lchild指向该节点的右孩子
  Rtag = 1 Lchild指向该节点的后继
  ```

- 先序线索

  - ```
    
    ```

- 增设一个头节点

  - Ltag = 0 指向根节点
  - rtag = 1 指向遍历序列的最后一个节点
  - 遍历序列中的第一个节点的Lchild 域和最后一个节点的Rchild 域指向头节点







### 数和森林的存储结构

- 双亲表示法

  - 数据域

  - 双亲域 数组，本节点的双亲在数组中的位置

  - ```
    PTNode{
    ElementType data；
    int parent；
    }
    PTree{
    	PTNode nodes[SIZE];
    	int r;根节点的位置
    	int n;节点个数
    }
    ```

    

- 孩子链表
  - 每个根节点组成一个指针线性表，每个指针指向一个链表，每个链表是该节点的子节点
  - 叶子的孩子链表为空表
  - 多加一块双亲域，即可快速找到双亲

- 孩子兄弟表示法
  - 二叉链表
  - 左节点指向第一个孩子，右节点指向下一个兄弟

### 树与森林的遍历

- ​	森林
  - 将森林看作三部分
    - 第一棵树的根节点
    - 第一个树构成的子树森林
    - 森林中其他树构成的森林

### 哈夫曼树 最优二叉树

- 判断树
  - 描述分类过程的二叉树
- 路径
  - 从一个节点到另一个节点之间的分支构成路径
  - 节点的路径长度：两阶段路径上的分支数
- 树的路径长度
  - 根到每一个节点的路径长度之和
  - 完全二叉树是路径长度最短的二叉树
- 权
  - 节点赋予一个有意义的数值，则为节点的权
- 节点的带权路径长度
  - 路径*该节点的权
- 树的带权路径长度
  - 树的所有**叶子**节点的带权路径长度之和



#### 最优二叉树

带权路径最短的二叉树

满二叉树不一定是哈夫曼树

权越大的叶子离根越近

### 哈夫曼树的构造

​	只有度为零和二的节点，，没有度为1的节点

​	节点数 = n + n-1 

- 贪心算法

  - ```
    根据n个权值
    构成n棵二叉树的森林
    1-----构造森林全是根
    2-----在F中选取两颗最小的根节点的权值最小的树为左右子树，构造一个新二叉树
    该树的权值为左右子树权值之和
    2-----选用两小造新树
    3-----在F中删除，新树加入
    删除两小添新人
    4-----重复至森林中只剩下一颗树
    ```


#### 算法实现

```
typedef struct{
	int weight;
	int parent lch,rch;
}HTNode,*HuffmanTree;
```



### 哈夫曼编码

1. 统计字符集中 字符出现的概论
2. 将概论作为权值，构造哈夫曼树
3. 前缀码
4. 最优前缀码



保证前缀编码？

因为没有一片树叶是另一片树叶的祖先，所以每个叶节点的编码就不可能是其他叶节点编码的前缀

字符编码总长最短？

因为带权路径长度最短，故字符编码的总长度最短

### 文件编码和解码





## 6-图

**G= (V,E)**

- V:顶点 有穷非空集合
- E：边的有穷集合

### 定义和术语

- 无向图：边不带方向
- 有向图：边带方向
- 完全图

  - 任意两个点都有一条边
  - 无向
    - n个顶点
    - n（n-1）/ 2 条边
  - 有向
    -  n（n-1） 条边
- 稀疏图
  - 边或弧很少
- 稠密图
- 网
  - 带权的边或弧
- 邻接
  - 有弧相链的两个顶点之间的关系
  - 存在（V1，V2）互为邻接点
  - v1邻接到v2，v2邻接与v1
- 顶点的度：
  - 与1该顶点相关联的边的数目
    - 有向图的度为入度和出度的和
- 路径
  - 接续的边构成的顶点序列
- 路径长度
  - 路径上边或弧的数目/权值的和
- 回路
  - 第一个和最后一个顶点相同
- 简单路径
- 简单回路
- 连通图 （强连通图）
  - 无向图
    - 存在任意两个顶点之间的路径，则为连通图
- 非联通
- 子图
- 连通分量
- 生成树
- 生成森林

### 类型定义

- ```
  ADT Graph{
  	集合
  	vR 弧集
  	Create 
  	DFS深度
  	BFS广度
  }
  ```

  